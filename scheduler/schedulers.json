{
  "schedulers": [
    {
      "name": "scx_bpfland",
      "production_ready": true,
      "description": "A BPF scheduler that prioritizes interactive workloads by detecting tasks with high voluntary contex",
      "use_cases": [
        "gaming",
        "live_streaming",
        "multimedia",
        "real_time_audio"
      ],
      "algorithm": "weighted_runtime",
      "characteristics": "latency optimization",
      "tuning_parameters": {
        "slice_us": {
          "type": "integer",
          "description": "Time slice duration in microseconds",
          "default": 5000,
          "range": [
            1000,
            20000
          ]
        },
        "nr_possible_cpus": {
          "type": "string",
          "description": "Number of possible CPUs to consider",
          "default": "auto-detected"
        },
        "stats": {
          "type": "boolean",
          "description": "Enable statistics collection",
          "default": false
        }
      },
      "limitations": "May not optimize for pure batch workloads, Limited configuration options",
      "performance_profile": "optimized for low latency"
    },
    {
      "name": "scx_central",
      "production_ready": false,
      "description": "A centralized scheduler where one CPU makes all scheduling decisions, allowing other cores to run wi",
      "use_cases": [
        "virtualization",
        "low_latency"
      ],
      "algorithm": "central_dispatch",
      "characteristics": "single cpu dispatch, infinite slices, timer tick reduction",
      "tuning_parameters": {
        "central_cpu": {
          "type": "integer",
          "description": "CPU ID to use for central scheduling",
          "default": 0
        }
      },
      "limitations": "Not production ready, No priority mechanism"
    },
    {
      "name": "scx_chaos",
      "production_ready": false,
      "description": "A chaos testing scheduler based on scx_p2dq that introduces controlled randomness to stress test sch",
      "use_cases": [
        "stress_testing",
        "debugging"
      ],
      "algorithm": "p2dq_with_chaos",
      "characteristics": "chaos testing",
      "tuning_parameters": {
        "chaos_level": {
          "type": "string",
          "description": "Level of chaos to introduce",
          "default": "medium"
        }
      },
      "limitations": "Not production ready, Unpredictable performance"
    },
    {
      "name": "scx_flash",
      "production_ready": true,
      "description": "An EDF scheduler that assigns dynamic latency weights based on CPU usage patterns. Tasks that releas",
      "use_cases": [
        "multimedia",
        "real_time_audio",
        "predictable_performance"
      ],
      "algorithm": "EDF",
      "characteristics": "dynamic latency weights, early cpu release priority, fairness focused, overcommit handling",
      "tuning_parameters": {
        "slice_us": {
          "type": "integer",
          "description": "Base time slice duration",
          "default": 5000,
          "range": [
            1000,
            20000
          ]
        },
        "latency_weight": {
          "type": "float",
          "description": "Weight for latency-sensitive tasks",
          "default": 1.0
        }
      },
      "limitations": "May not optimize for pure throughput, Complex latency weight tuning",
      "performance_profile": "optimized for low latency, good throughput"
    },
    {
      "name": "scx_flatcg",
      "production_ready": true,
      "description": "A high-performance cgroup-aware scheduler that flattens the cgroup hierarchy for better performance ",
      "use_cases": [
        "container_workloads",
        "resource_management"
      ],
      "algorithm": "flattened_cgroup_hierarchy",
      "characteristics": "cgroup hierarchy flattening, weight based control, performance optimization, thundering herd limitation",
      "tuning_parameters": {
        "cgroup_weights": {
          "type": "integer",
          "description": "CPU weight allocation for cgroups",
          "default": 1024,
          "range": [
            1,
            10000
          ]
        }
      },
      "limitations": "Limited to cgroup use cases, Thundering herd issues possible"
    },
    {
      "name": "scx_lavd",
      "production_ready": true,
      "description": "A sophisticated latency-aware scheduler that measures task latency criticality and uses virtual dead",
      "use_cases": [
        "gaming",
        "interactive_applications"
      ],
      "algorithm": "LAVD",
      "characteristics": "latency criticality measurement, virtual deadline scheduling, per llc domains, core type awareness, numa awareness",
      "tuning_parameters": {
        "slice_us": {
          "type": "integer",
          "description": "Time slice duration in microseconds",
          "default": 20000,
          "range": [
            5000,
            100000
          ]
        },
        "interactive_threshold": {
          "type": "integer",
          "description": "Threshold for interactive task detection",
          "default": 50,
          "range": [
            1,
            1000
          ]
        },
        "balanced_profile": {
          "type": "boolean",
          "description": "Use balanced performance profile",
          "default": true
        }
      },
      "limitations": "Complex configuration, May not optimize for batch processing",
      "performance_profile": "optimized for low latency"
    },
    {
      "name": "scx_layered",
      "production_ready": true,
      "description": "A highly configurable multi-layer scheduler that allows creating custom layers with different schedu",
      "use_cases": [
        "custom_applications",
        "priority_services"
      ],
      "algorithm": "layer_based",
      "characteristics": "task classification, multiple scheduling policies, cpu utilization guarantees, topology awareness, performance control, numa node affinity",
      "tuning_parameters": {
        "config_file": {
          "type": "string",
          "description": "JSON configuration file defining layers",
          "default": "none"
        },
        "slice_us": {
          "type": "integer",
          "description": "Time slice per layer in microseconds",
          "default": 20000,
          "range": [
            1000,
            100000
          ]
        },
        "util_range": {
          "type": "string",
          "description": "CPU utilization range for layer growth/shrink",
          "default": "[0.8, 0.9]"
        },
        "perf": {
          "type": "integer",
          "description": "Performance level (0-1024) for CPU frequency control",
          "default": 1024
        }
      },
      "limitations": "Complex configuration, Requires tuning",
      "performance_profile": "optimized for low latency"
    },
    {
      "name": "scx_mitosis",
      "production_ready": false,
      "description": "No description available - empty documentation file",
      "use_cases": [
        "general_purpose"
      ],
      "algorithm": "unknown",
      "characteristics": "empty description",
      "tuning_parameters": {},
      "limitations": "No documentation, Unknown functionality"
    },
    {
      "name": "scx_nest",
      "production_ready": true,
      "description": "A frequency-optimized scheduler that keeps tasks on warm cores to maintain high CPU frequencies. Bes",
      "use_cases": [
        "low_cpu_utilization",
        "frequency_sensitive"
      ],
      "algorithm": "warm_core_clustering",
      "characteristics": "warm core prioritization, frequency optimization, single ccx limitation, cache locality awareness",
      "tuning_parameters": {
        "primary_core": {
          "type": "integer",
          "description": "Primary core for task placement",
          "default": 0
        },
        "spread_tasks": {
          "type": "boolean",
          "description": "Whether to spread tasks across cores",
          "default": false
        }
      },
      "limitations": "Limited to single CCX, Not good for high CPU utilization"
    },
    {
      "name": "scx_p2dq",
      "production_ready": true,
      "description": "A versatile scheduler with multi-layer queuing and slice-based task classification. Automatically de",
      "use_cases": [
        "interactive",
        "batch_processing",
        "server_applications"
      ],
      "algorithm": "pick_two_load_balancing",
      "characteristics": "multi layer queuing, slice based classification, interactive detection, load balancing across llc, configurable time slices",
      "tuning_parameters": {
        "nr_queues": {
          "type": "integer",
          "description": "Number of dispatch queues",
          "default": 8,
          "range": [
            2,
            16
          ]
        },
        "slice_us": {
          "type": "integer",
          "description": "Base time slice duration",
          "default": 20000,
          "range": [
            5000,
            100000
          ]
        },
        "interactive_ratio": {
          "type": "float",
          "description": "Ratio of interactive to batch tasks",
          "default": 0.5
        }
      },
      "limitations": "May need tuning for specific workloads, Complex queue management"
    },
    {
      "name": "scx_rusty",
      "production_ready": true,
      "description": "A production-ready multi-domain scheduler with intelligent load balancing. Creates separate scheduli",
      "use_cases": [
        "general_purpose",
        "multi_architecture"
      ],
      "algorithm": "multi_domain_round_robin",
      "characteristics": "multi domain support, per llc domains, user space load balancing, configurable thresholds, architecture flexibility",
      "tuning_parameters": {
        "slice_us": {
          "type": "integer",
          "description": "Time slice duration in microseconds",
          "default": 20000,
          "range": [
            1000,
            100000
          ]
        },
        "greedy_threshold": {
          "type": "integer",
          "description": "Threshold for greedy task stealing",
          "default": 2,
          "range": [
            1,
            10
          ]
        },
        "kthreads": {
          "type": "boolean",
          "description": "Schedule kernel threads",
          "default": false
        },
        "fifo_sched": {
          "type": "boolean",
          "description": "Use FIFO scheduling within domains",
          "default": false
        }
      },
      "limitations": "May not distinguish NUMA nodes well, Potential infeasible weights issue"
    },
    {
      "name": "scx_simple",
      "production_ready": true,
      "description": "A simple scheduler with minimal complexity, supporting both weighted vtime and FIFO modes. Good for ",
      "use_cases": [
        "single_socket",
        "uniform_l3_cache"
      ],
      "algorithm": "simple_vtime_or_fifo",
      "characteristics": "dual mode operation, minimal complexity, single socket optimized, starvation risk in fifo",
      "tuning_parameters": {
        "fifo": {
          "type": "boolean",
          "description": "Use FIFO mode instead of vtime",
          "default": false
        },
        "slice_us": {
          "type": "integer",
          "description": "Time slice duration",
          "default": 20000,
          "range": [
            1000,
            100000
          ]
        }
      },
      "limitations": "Limited scalability, May not optimize complex workloads"
    },
    {
      "name": "scx_tickless",
      "production_ready": false,
      "description": "An experimental server-oriented scheduler designed to reduce OS noise by minimizing timer ticks. Use",
      "use_cases": [
        "cloud_computing",
        "virtualization",
        "hpc"
      ],
      "algorithm": "primary_cpu_distribution",
      "characteristics": "tick reduction, primary cpu pool, os noise reduction, global task queue, configurable frequency, nohz full requirement",
      "tuning_parameters": {
        "primary_domain": {
          "type": "integer",
          "description": "CPU mask for primary scheduling CPUs",
          "default": 0
        },
        "frequency": {
          "type": "integer",
          "description": "Scheduling frequency",
          "default": 100
        }
      },
      "requirements": "Linux kernel with nohz_full support",
      "limitations": "Not production ready, Experimental"
    },
    {
      "name": "scx_userland",
      "production_ready": false,
      "description": "A fully user-space scheduler for educational purposes. Demonstrates user-space scheduling concepts b",
      "use_cases": [
        "demonstration",
        "educational"
      ],
      "algorithm": "user_space_vtime",
      "characteristics": "full user space implementation, ordered list scheduling, development advantages, deadlock risk, performance overhead",
      "tuning_parameters": {
        "slice_us": {
          "type": "integer",
          "description": "Time slice duration",
          "default": 20000
        }
      },
      "limitations": "Not production ready, Performance overhead"
    }
  ]
}